def can_place_h(word, r, c, grid):
    return c >= 0 and c + len(word) <= grid.shape[1]

def can_place_v(word, r, c, grid):
    return r >= 0 and r + len(word) <= grid.shape[0]

start_row = vertical // 2
start_col = horizontal // 2

grid = np.full((vertical, horizontal), ' ', dtype='<U1')

first_word = common_random_selections[0]

row = vertical // 2
col = (horizontal - len(first_word)) // 2

for i, ch in enumerate(first_word):
    grid[row, col + i] = ch

current_row, current_col = row, col
current_dir = original_dir

for i, word in enumerate(common_random_selections[1:]):
    overlap_char = overlaps[i]

    prev_word = common_random_selections[i]
    prev_index = prev_word.index(overlap_char)
    curr_index = word.index(overlap_char)

    if current_dir == 'r':  # place vertically
        cross_row = current_row
        cross_col = current_col + prev_index

        start_r = cross_row - curr_index
        start_c = cross_col

        if not can_place_v(word, start_r, start_c, grid):
            continue

        for j, ch in enumerate(word):
            grid[start_r + j, start_c] = ch

        current_row = start_r
        current_col = start_c
        current_dir = 'c'

    else: 
        cross_row = current_row + prev_index
        cross_col = current_col

        start_r = cross_row
        start_c = cross_col - curr_index

        if not can_place_h(word, start_r, start_c, grid):
            continue

        for j, ch in enumerate(word):
            grid[start_r, start_c + j] = ch

        current_row = start_r
        current_col = start_c
        current_dir = 'r'

print(grid)      